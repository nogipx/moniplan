// SPDX-FileCopyrightText: 2025 Karim "nogipx" Mamatkazin <nogipx@gmail.com>
//
// SPDX-License-Identifier: GPL-3.0-or-later

import 'dart:math';

/// Масштабирует значение из диапазона [0, 1] в диапазон [a, b].
///
/// [value]: значение, которое должно быть в диапазоне [0, 1].
/// [a], [b]: границы нового диапазона.
///
/// Возвращает значение, пропорционально масштабированное из диапазона [0, 1] в [a, b].
/// Оптимизация: Используем умножение вместо деления для повышения эффективности.
///
/// Математическое обоснование: Линейная интерполяция используется для масштабирования значения.
/// Формула: result = a + (b - a) * value, где value находится в диапазоне [0, 1].
/// Это позволяет линейно преобразовать значение в новый диапазон [a, b].
double scaleToRange(double value, double a, double b) {
  return a + (b - a) * value;
}

/// Нормализует значение из диапазона [min, max] в диапазон [a, b].
///
/// [value]: значение, которое должно быть нормализовано.
/// [min], [max]: исходные границы диапазона.
/// [a], [b]: границы нового диапазона.
///
/// Возвращает значение, нормализованное из диапазона [min, max] в [a, b].
/// Оптимизация: Предварительно сохраняем коэффициент масштабирования для минимизации операций.
///
/// Математическое обоснование: Используется линейная нормализация, которая позволяет преобразовать
/// значение из одного диапазона в другой. Формула: result = a + (value - min) * (b - a) / (max - min).
/// Это позволяет вычислить новое значение, линейно масштабированное в новый диапазон [a, b].
double normalizeToRange(double value, double min, double max, double a, double b) {
  return a + (value - min) * (b - a) / (max - min);
}

/// Вычисляет значение гауссовой функции для входного значения в диапазоне [0, 1].
///
/// [value]: входное значение, которое должно быть в диапазоне [0, 1].
///
/// Использует параметры среднего значения (mean) и обратной величины двух сигм в квадрате (invTwoSigmaSq).
/// Оптимизация: Предварительно вычисляем константы для минимизации повторных операций.
///
/// Математическое обоснование: Гауссова функция определяется как exp(-(x - mean)^2 / (2 * sigma^2)).
/// В этой реализации mean = 0.5 и sigma = 0.15. Мы используем заранее вычисленное значение
/// invTwoSigmaSq = 1 / (2 * sigma^2) для оптимизации. Эта функция создает колоколообразную кривую,
/// которая описывает нормальное распределение, центрированное на 0.5.
double gaussianFunction(double value) {
  const mean = 0.5; // Среднее значение распределения
  const invTwoSigmaSq = 1 / (2 * 0.15 * 0.15); // Обратная величина двух сигм в квадрате
  final diff = value - mean; // Разница между значением и средним
  return exp(-diff * diff * invTwoSigmaSq);
}

/// Вычисляет значение кардинального синуса (sinc) для входного значения.
///
/// [value]: входное значение, которое должно быть в диапазоне [0, 1].
///
/// Оптимизация: Используем epsilon для проверки на значение, близкое к нулю, чтобы избежать деления на ноль.
///
/// Математическое обоснование: Функция sinc(x) определяется как sin(pi * x) / (pi * x), где x != 0,
/// и равна 1 при x = 0. Эта функция полезна для обработки сигналов и интерполяции, так как
/// создает гладкую кривую, пересекающуюся с нулем в определенных точках. Чтобы избежать деления на ноль,
/// используется проверка на значение, близкое к нулю.
double cardinalSineFunction(double value) {
  if (value.abs() < 1e-10) {
    return 1; // Для значения, близкого к нулю, возвращаем 1.0
  }
  final piValue = pi * value; // Сохраняем значение pi * value для многократного использования
  return sin(piValue) / piValue;
}

/// Вычисляет синусоидальную функцию для входного значения.
///
/// [value]: входное значение, которое должно быть в диапазоне [0, 1].
///
/// Оптимизация: Минимизируем количество арифметических операций для повышения производительности.
/// Возвращает значение в диапазоне [0, 1], соответствующее синусоиде с периодом 1.
///
/// Математическое обоснование: Синусоидальная функция используется для создания плавного осциллирующего
/// значения в диапазоне [0, 1]. Формула: result = 0.5 + 0.5 * sin(2 * pi * value). Эта формула
/// позволяет преобразовать синусоиду из диапазона [-1, 1] в диапазон [0, 1], добавляя и деля на 2.
double sinusoidalFunction(double value) {
  return 0.5 + 0.5 * sin(2 * pi * value);
}
